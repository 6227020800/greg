{"version":3,"sources":["assets/js/mustache.js"],"names":["global","factory","exports","module","define","amd","self","Mustache","objectToString","Object","prototype","toString","isArray","Array","isArrayPolyfill","object","call","isFunction","typeStr","obj","escapeRegExp","string","replace","hasProperty","propName","primitiveHasOwnProperty","primitive","hasOwnProperty","regExpTest","RegExp","test","testRegExp","re","nonSpaceRe","isWhitespace","entityMap","escapeHtml","String","fromEntityMap","s","whiteRe","spaceRe","equalsRe","curlyRe","tagRe","parseTemplate","template","tags","lineHasNonSpace","sections","tokens","spaces","hasTag","nonSpace","indentation","tagIndex","stripSpace","length","pop","openingTagRe","closingTagRe","closingCurlyRe","compileTags","tagsToCompile","split","Error","mustache","scanner","Scanner","start","type","value","chr","token","openSection","eos","pos","scanUntil","i","valueLength","charAt","push","scan","nestTokens","squashTokens","squashedTokens","lastToken","numTokens","nestedTokens","collector","section","tail","match","index","substring","search","Context","view","parentContext","cache","parent","lookup","name","context","intermediateValue","names","lookupHit","indexOf","Writer","templateCache","_cache","set","key","get","clear","clearCache","parse","cacheKey","join","isCacheEnabled","undefined","render","partials","config","getConfigTags","renderTokens","originalTemplate","buffer","symbol","renderSection","renderInverted","renderPartial","unescapedValue","escapedValue","rawValue","subRender","j","slice","indentPartial","partial","filteredIndentation","partialByNl","indentedValue","escape","getConfigEscape","version","defaultWriter","TypeError"],"mappings":"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","file":"mustache.78316254.js","sourceRoot":"../application","sourcesContent":["// This file has been generated from mustache.mjs\n(function(global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n        typeof define === 'function' && define.amd ? define(factory) :\n        (global = global || self, global.Mustache = factory());\n}(this, (function() {\n    'use strict';\n\n    /*!\n     * mustache.js - Logic-less {{mustache}} templates with JavaScript\n     * http://github.com/janl/mustache.js\n     */\n\n    var objectToString = Object.prototype.toString;\n    var isArray = Array.isArray || function isArrayPolyfill(object) {\n        return objectToString.call(object) === '[object Array]';\n    };\n\n    function isFunction(object) {\n        return typeof object === 'function';\n    }\n\n    /**\n     * More correct typeof string handling array\n     * which normally returns typeof 'object'\n     */\n    function typeStr(obj) {\n        return isArray(obj) ? 'array' : typeof obj;\n    }\n\n    function escapeRegExp(string) {\n        return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n    }\n\n    /**\n     * Null safe way of checking whether or not an object,\n     * including its prototype, has a given property\n     */\n    function hasProperty(obj, propName) {\n        return obj != null && typeof obj === 'object' && (propName in obj);\n    }\n\n    /**\n     * Safe way of detecting whether or not the given thing is a primitive and\n     * whether it has the given property\n     */\n    function primitiveHasOwnProperty(primitive, propName) {\n        return (\n            primitive != null &&\n            typeof primitive !== 'object' &&\n            primitive.hasOwnProperty &&\n            primitive.hasOwnProperty(propName)\n        );\n    }\n\n    // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n    // See https://github.com/janl/mustache.js/issues/189\n    var regExpTest = RegExp.prototype.test;\n\n    function testRegExp(re, string) {\n        return regExpTest.call(re, string);\n    }\n\n    var nonSpaceRe = /\\S/;\n\n    function isWhitespace(string) {\n        return !testRegExp(nonSpaceRe, string);\n    }\n\n    var entityMap = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#39;',\n        '/': '&#x2F;',\n        '`': '&#x60;',\n        '=': '&#x3D;'\n    };\n\n    function escapeHtml(string) {\n        return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap(s) {\n            return entityMap[s];\n        });\n    }\n\n    var whiteRe = /\\s*/;\n    var spaceRe = /\\s+/;\n    var equalsRe = /\\s*=/;\n    var curlyRe = /\\s*\\}/;\n    var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n    /**\n     * Breaks up the given `template` string into a tree of tokens. If the `tags`\n     * argument is given here it must be an array with two string values: the\n     * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n     * course, the default is to use mustaches (i.e. mustache.tags).\n     *\n     * A token is an array with at least 4 elements. The first element is the\n     * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n     * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n     * all text that appears outside a symbol this element is \"text\".\n     *\n     * The second element of a token is its \"value\". For mustache tags this is\n     * whatever else was inside the tag besides the opening symbol. For text tokens\n     * this is the text itself.\n     *\n     * The third and fourth elements of the token are the start and end indices,\n     * respectively, of the token in the original template.\n     *\n     * Tokens that are the root node of a subtree contain two more elements: 1) an\n     * array of tokens in the subtree and 2) the index in the original template at\n     * which the closing tag for that section begins.\n     *\n     * Tokens for partials also contain two more elements: 1) a string value of\n     * indendation prior to that tag and 2) the index of that tag on that line -\n     * eg a value of 2 indicates the partial is the third tag on this line.\n     */\n    function parseTemplate(template, tags) {\n        if (!template)\n            return [];\n        var lineHasNonSpace = false;\n        var sections = []; // Stack to hold section tokens\n        var tokens = []; // Buffer to hold the tokens\n        var spaces = []; // Indices of whitespace tokens on the current line\n        var hasTag = false; // Is there a {{tag}} on the current line?\n        var nonSpace = false; // Is there a non-space char on the current line?\n        var indentation = ''; // Tracks indentation for tags that use it\n        var tagIndex = 0; // Stores a count of number of tags encountered on a line\n\n        // Strips all whitespace tokens array for the current line\n        // if there was a {{#tag}} on it and otherwise only space.\n        function stripSpace() {\n            if (hasTag && !nonSpace) {\n                while (spaces.length)\n                    delete tokens[spaces.pop()];\n            } else {\n                spaces = [];\n            }\n\n            hasTag = false;\n            nonSpace = false;\n        }\n\n        var openingTagRe, closingTagRe, closingCurlyRe;\n\n        function compileTags(tagsToCompile) {\n            if (typeof tagsToCompile === 'string')\n                tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n            if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n                throw new Error('Invalid tags: ' + tagsToCompile);\n\n            openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n            closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n            closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n        }\n\n        compileTags(tags || mustache.tags);\n\n        var scanner = new Scanner(template);\n\n        var start, type, value, chr, token, openSection;\n        while (!scanner.eos()) {\n            start = scanner.pos;\n\n            // Match any text between tags.\n            value = scanner.scanUntil(openingTagRe);\n\n            if (value) {\n                for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n                    chr = value.charAt(i);\n\n                    if (isWhitespace(chr)) {\n                        spaces.push(tokens.length);\n                        indentation += chr;\n                    } else {\n                        nonSpace = true;\n                        lineHasNonSpace = true;\n                        indentation += ' ';\n                    }\n\n                    tokens.push(['text', chr, start, start + 1]);\n                    start += 1;\n\n                    // Check for whitespace on the current line.\n                    if (chr === '\\n') {\n                        stripSpace();\n                        indentation = '';\n                        tagIndex = 0;\n                        lineHasNonSpace = false;\n                    }\n                }\n            }\n\n            // Match the opening tag.\n            if (!scanner.scan(openingTagRe))\n                break;\n\n            hasTag = true;\n\n            // Get the tag type.\n            type = scanner.scan(tagRe) || 'name';\n            scanner.scan(whiteRe);\n\n            // Get the tag value.\n            if (type === '=') {\n                value = scanner.scanUntil(equalsRe);\n                scanner.scan(equalsRe);\n                scanner.scanUntil(closingTagRe);\n            } else if (type === '{') {\n                value = scanner.scanUntil(closingCurlyRe);\n                scanner.scan(curlyRe);\n                scanner.scanUntil(closingTagRe);\n                type = '&';\n            } else {\n                value = scanner.scanUntil(closingTagRe);\n            }\n\n            // Match the closing tag.\n            if (!scanner.scan(closingTagRe))\n                throw new Error('Unclosed tag at ' + scanner.pos);\n\n            if (type == '>') {\n                token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];\n            } else {\n                token = [type, value, start, scanner.pos];\n            }\n            tagIndex++;\n            tokens.push(token);\n\n            if (type === '#' || type === '^') {\n                sections.push(token);\n            } else if (type === '/') {\n                // Check section nesting.\n                openSection = sections.pop();\n\n                if (!openSection)\n                    throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n                if (openSection[1] !== value)\n                    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n            } else if (type === 'name' || type === '{' || type === '&') {\n                nonSpace = true;\n            } else if (type === '=') {\n                // Set the tags for the next time around.\n                compileTags(value);\n            }\n        }\n\n        stripSpace();\n\n        // Make sure there are no open sections when we're done.\n        openSection = sections.pop();\n\n        if (openSection)\n            throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n        return nestTokens(squashTokens(tokens));\n    }\n\n    /**\n     * Combines the values of consecutive text tokens in the given `tokens` array\n     * to a single token.\n     */\n    function squashTokens(tokens) {\n        var squashedTokens = [];\n\n        var token, lastToken;\n        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n            token = tokens[i];\n\n            if (token) {\n                if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n                    lastToken[1] += token[1];\n                    lastToken[3] = token[3];\n                } else {\n                    squashedTokens.push(token);\n                    lastToken = token;\n                }\n            }\n        }\n\n        return squashedTokens;\n    }\n\n    /**\n     * Forms the given array of `tokens` into a nested tree structure where\n     * tokens that represent a section have two additional items: 1) an array of\n     * all tokens that appear in that section and 2) the index in the original\n     * template that represents the end of that section.\n     */\n    function nestTokens(tokens) {\n        var nestedTokens = [];\n        var collector = nestedTokens;\n        var sections = [];\n\n        var token, section;\n        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n            token = tokens[i];\n\n            switch (token[0]) {\n                case '#':\n                case '^':\n                    collector.push(token);\n                    sections.push(token);\n                    collector = token[4] = [];\n                    break;\n                case '/':\n                    section = sections.pop();\n                    section[5] = token[2];\n                    collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n                    break;\n                default:\n                    collector.push(token);\n            }\n        }\n\n        return nestedTokens;\n    }\n\n    /**\n     * A simple string scanner that is used by the template parser to find\n     * tokens in template strings.\n     */\n    function Scanner(string) {\n        this.string = string;\n        this.tail = string;\n        this.pos = 0;\n    }\n\n    /**\n     * Returns `true` if the tail is empty (end of string).\n     */\n    Scanner.prototype.eos = function eos() {\n        return this.tail === '';\n    };\n\n    /**\n     * Tries to match the given regular expression at the current position.\n     * Returns the matched text if it can match, the empty string otherwise.\n     */\n    Scanner.prototype.scan = function scan(re) {\n        var match = this.tail.match(re);\n\n        if (!match || match.index !== 0)\n            return '';\n\n        var string = match[0];\n\n        this.tail = this.tail.substring(string.length);\n        this.pos += string.length;\n\n        return string;\n    };\n\n    /**\n     * Skips all text until the given regular expression can be matched. Returns\n     * the skipped string, which is the entire tail if no match can be made.\n     */\n    Scanner.prototype.scanUntil = function scanUntil(re) {\n        var index = this.tail.search(re),\n            match;\n\n        switch (index) {\n            case -1:\n                match = this.tail;\n                this.tail = '';\n                break;\n            case 0:\n                match = '';\n                break;\n            default:\n                match = this.tail.substring(0, index);\n                this.tail = this.tail.substring(index);\n        }\n\n        this.pos += match.length;\n\n        return match;\n    };\n\n    /**\n     * Represents a rendering context by wrapping a view object and\n     * maintaining a reference to the parent context.\n     */\n    function Context(view, parentContext) {\n        this.view = view;\n        this.cache = {\n            '.': this.view\n        };\n        this.parent = parentContext;\n    }\n\n    /**\n     * Creates a new context using the given view with this context\n     * as the parent.\n     */\n    Context.prototype.push = function push(view) {\n        return new Context(view, this);\n    };\n\n    /**\n     * Returns the value of the given name in this context, traversing\n     * up the context hierarchy if the value is absent in this context's view.\n     */\n    Context.prototype.lookup = function lookup(name) {\n        var cache = this.cache;\n\n        var value;\n        if (cache.hasOwnProperty(name)) {\n            value = cache[name];\n        } else {\n            var context = this,\n                intermediateValue, names, index, lookupHit = false;\n\n            while (context) {\n                if (name.indexOf('.') > 0) {\n                    intermediateValue = context.view;\n                    names = name.split('.');\n                    index = 0;\n\n                    /**\n                     * Using the dot notion path in `name`, we descend through the\n                     * nested objects.\n                     *\n                     * To be certain that the lookup has been successful, we have to\n                     * check if the last object in the path actually has the property\n                     * we are looking for. We store the result in `lookupHit`.\n                     *\n                     * This is specially necessary for when the value has been set to\n                     * `undefined` and we want to avoid looking up parent contexts.\n                     *\n                     * In the case where dot notation is used, we consider the lookup\n                     * to be successful even if the last \"object\" in the path is\n                     * not actually an object but a primitive (e.g., a string, or an\n                     * integer), because it is sometimes useful to access a property\n                     * of an autoboxed primitive, such as the length of a string.\n                     **/\n                    while (intermediateValue != null && index < names.length) {\n                        if (index === names.length - 1)\n                            lookupHit = (\n                                hasProperty(intermediateValue, names[index]) ||\n                                primitiveHasOwnProperty(intermediateValue, names[index])\n                            );\n\n                        intermediateValue = intermediateValue[names[index++]];\n                    }\n                } else {\n                    intermediateValue = context.view[name];\n\n                    /**\n                     * Only checking against `hasProperty`, which always returns `false` if\n                     * `context.view` is not an object. Deliberately omitting the check\n                     * against `primitiveHasOwnProperty` if dot notation is not used.\n                     *\n                     * Consider this example:\n                     * ```\n                     * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\n                     * ```\n                     *\n                     * If we were to check also against `primitiveHasOwnProperty`, as we do\n                     * in the dot notation case, then render call would return:\n                     *\n                     * \"The length of a football field is 9.\"\n                     *\n                     * rather than the expected:\n                     *\n                     * \"The length of a football field is 100 yards.\"\n                     **/\n                    lookupHit = hasProperty(context.view, name);\n                }\n\n                if (lookupHit) {\n                    value = intermediateValue;\n                    break;\n                }\n\n                context = context.parent;\n            }\n\n            cache[name] = value;\n        }\n\n        if (isFunction(value))\n            value = value.call(this.view);\n\n        return value;\n    };\n\n    /**\n     * A Writer knows how to take a stream of tokens and render them to a\n     * string, given a context. It also maintains a cache of templates to\n     * avoid the need to parse the same template twice.\n     */\n    function Writer() {\n        this.templateCache = {\n            _cache: {},\n            set: function set(key, value) {\n                this._cache[key] = value;\n            },\n            get: function get(key) {\n                return this._cache[key];\n            },\n            clear: function clear() {\n                this._cache = {};\n            }\n        };\n    }\n\n    /**\n     * Clears all cached templates in this writer.\n     */\n    Writer.prototype.clearCache = function clearCache() {\n        if (typeof this.templateCache !== 'undefined') {\n            this.templateCache.clear();\n        }\n    };\n\n    /**\n     * Parses and caches the given `template` according to the given `tags` or\n     * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\n     * that is generated from the parse.\n     */\n    Writer.prototype.parse = function parse(template, tags) {\n        var cache = this.templateCache;\n        var cacheKey = template + ':' + (tags || mustache.tags).join(':');\n        var isCacheEnabled = typeof cache !== 'undefined';\n        var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\n\n        if (tokens == undefined) {\n            tokens = parseTemplate(template, tags);\n            isCacheEnabled && cache.set(cacheKey, tokens);\n        }\n        return tokens;\n    };\n\n    /**\n     * High-level method that is used to render the given `template` with\n     * the given `view`.\n     *\n     * The optional `partials` argument may be an object that contains the\n     * names and templates of partials that are used in the template. It may\n     * also be a function that is used to load partial templates on the fly\n     * that takes a single argument: the name of the partial.\n     *\n     * If the optional `config` argument is given here, then it should be an\n     * object with a `tags` attribute or an `escape` attribute or both.\n     * If an array is passed, then it will be interpreted the same way as\n     * a `tags` attribute on a `config` object.\n     *\n     * The `tags` attribute of a `config` object must be an array with two\n     * string values: the opening and closing tags used in the template (e.g.\n     * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n     *\n     * The `escape` attribute of a `config` object must be a function which\n     * accepts a string as input and outputs a safely escaped string.\n     * If an `escape` function is not provided, then an HTML-safe string\n     * escaping function is used as the default.\n     */\n    Writer.prototype.render = function render(template, view, partials, config) {\n        var tags = this.getConfigTags(config);\n        var tokens = this.parse(template, tags);\n        var context = (view instanceof Context) ? view : new Context(view, undefined);\n        return this.renderTokens(tokens, context, partials, template, config);\n    };\n\n    /**\n     * Low-level method that renders the given array of `tokens` using\n     * the given `context` and `partials`.\n     *\n     * Note: The `originalTemplate` is only ever used to extract the portion\n     * of the original template that was contained in a higher-order section.\n     * If the template doesn't use higher-order sections, this argument may\n     * be omitted.\n     */\n    Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {\n        var buffer = '';\n\n        var token, symbol, value;\n        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n            value = undefined;\n            token = tokens[i];\n            symbol = token[0];\n\n            if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);\n            else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);\n            else if (symbol === '>') value = this.renderPartial(token, context, partials, config);\n            else if (symbol === '&') value = this.unescapedValue(token, context);\n            else if (symbol === 'name') value = this.escapedValue(token, context, config);\n            else if (symbol === 'text') value = this.rawValue(token);\n\n            if (value !== undefined)\n                buffer += value;\n        }\n\n        return buffer;\n    };\n\n    Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {\n        var self = this;\n        var buffer = '';\n        var value = context.lookup(token[1]);\n\n        // This function is used to render an arbitrary template\n        // in the current context by higher-order sections.\n        function subRender(template) {\n            return self.render(template, context, partials, config);\n        }\n\n        if (!value) return;\n\n        if (isArray(value)) {\n            for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n                buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\n            }\n        } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n            buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\n        } else if (isFunction(value)) {\n            if (typeof originalTemplate !== 'string')\n                throw new Error('Cannot use higher-order sections without the original template');\n\n            // Extract the portion of the original template that the section contains.\n            value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n            if (value != null)\n                buffer += value;\n        } else {\n            buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\n        }\n        return buffer;\n    };\n\n    Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {\n        var value = context.lookup(token[1]);\n\n        // Use JavaScript's definition of falsy. Include empty arrays.\n        // See https://github.com/janl/mustache.js/issues/186\n        if (!value || (isArray(value) && value.length === 0))\n            return this.renderTokens(token[4], context, partials, originalTemplate, config);\n    };\n\n    Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {\n        var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\n        var partialByNl = partial.split('\\n');\n        for (var i = 0; i < partialByNl.length; i++) {\n            if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\n                partialByNl[i] = filteredIndentation + partialByNl[i];\n            }\n        }\n        return partialByNl.join('\\n');\n    };\n\n    Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {\n        if (!partials) return;\n        var tags = this.getConfigTags(config);\n\n        var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n        if (value != null) {\n            var lineHasNonSpace = token[6];\n            var tagIndex = token[5];\n            var indentation = token[4];\n            var indentedValue = value;\n            if (tagIndex == 0 && indentation) {\n                indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\n            }\n            var tokens = this.parse(indentedValue, tags);\n            return this.renderTokens(tokens, context, partials, indentedValue, config);\n        }\n    };\n\n    Writer.prototype.unescapedValue = function unescapedValue(token, context) {\n        var value = context.lookup(token[1]);\n        if (value != null)\n            return value;\n    };\n\n    Writer.prototype.escapedValue = function escapedValue(token, context, config) {\n        var escape = this.getConfigEscape(config) || mustache.escape;\n        var value = context.lookup(token[1]);\n        if (value != null)\n            return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);\n    };\n\n    Writer.prototype.rawValue = function rawValue(token) {\n        return token[1];\n    };\n\n    Writer.prototype.getConfigTags = function getConfigTags(config) {\n        if (isArray(config)) {\n            return config;\n        } else if (config && typeof config === 'object') {\n            return config.tags;\n        } else {\n            return undefined;\n        }\n    };\n\n    Writer.prototype.getConfigEscape = function getConfigEscape(config) {\n        if (config && typeof config === 'object' && !isArray(config)) {\n            return config.escape;\n        } else {\n            return undefined;\n        }\n    };\n\n    var mustache = {\n        name: 'mustache.js',\n        version: '4.1.0',\n        tags: ['{{', '}}'],\n        clearCache: undefined,\n        escape: undefined,\n        parse: undefined,\n        render: undefined,\n        Scanner: undefined,\n        Context: undefined,\n        Writer: undefined,\n        /**\n         * Allows a user to override the default caching strategy, by providing an\n         * object with set, get and clear methods. This can also be used to disable\n         * the cache by setting it to the literal `undefined`.\n         */\n        set templateCache(cache) {\n            defaultWriter.templateCache = cache;\n        },\n        /**\n         * Gets the default or overridden caching object from the default writer.\n         */\n        get templateCache() {\n            return defaultWriter.templateCache;\n        }\n    };\n\n    // All high-level mustache.* functions use this writer.\n    var defaultWriter = new Writer();\n\n    /**\n     * Clears all cached templates in the default writer.\n     */\n    mustache.clearCache = function clearCache() {\n        return defaultWriter.clearCache();\n    };\n\n    /**\n     * Parses and caches the given template in the default writer and returns the\n     * array of tokens it contains. Doing this ahead of time avoids the need to\n     * parse templates on the fly as they are rendered.\n     */\n    mustache.parse = function parse(template, tags) {\n        return defaultWriter.parse(template, tags);\n    };\n\n    /**\n     * Renders the `template` with the given `view`, `partials`, and `config`\n     * using the default writer.\n     */\n    mustache.render = function render(template, view, partials, config) {\n        if (typeof template !== 'string') {\n            throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                'but \"' + typeStr(template) + '\" was given as the first ' +\n                'argument for mustache#render(template, view, partials)');\n        }\n\n        return defaultWriter.render(template, view, partials, config);\n    };\n\n    // Export the escaping function so that the user may override it.\n    // See https://github.com/janl/mustache.js/issues/244\n    mustache.escape = escapeHtml;\n\n    // Export these mainly for testing, but also for advanced usage.\n    mustache.Scanner = Scanner;\n    mustache.Context = Context;\n    mustache.Writer = Writer;\n\n    return mustache;\n\n})));"]}