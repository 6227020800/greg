{"version":3,"sources":["assets/js/mustache.js"],"names":["global","factory","exports","module","define","amd","self","Mustache","objectToString","Object","prototype","toString","isArray","Array","object","call","isFunction","escapeRegExp","string","replace","hasProperty","obj","propName","regExpTest","RegExp","test","nonSpaceRe","isWhitespace","testRegExp","re","entityMap","whiteRe","spaceRe","equalsRe","curlyRe","tagRe","Scanner","tail","pos","Context","view","parentContext","cache","parent","Writer","templateCache","_cache","set","key","value","get","clear","eos","scan","match","index","substring","length","scanUntil","search","push","lookup","name","primitive","hasOwnProperty","context","intermediateValue","names","lookupHit","indexOf","split","clearCache","parse","template","tags","cacheKey","mustache","join","isCacheEnabled","tokens","undefined","parseTemplate","lineHasNonSpace","openingTagRe","closingTagRe","closingCurlyRe","sections","spaces","hasTag","nonSpace","indentation","tagIndex","stripSpace","pop","compileTags","tagsToCompile","Error","scanner","start","type","chr","token","openSection","i","valueLength","charAt","nestTokens","nestedTokens","collector","numTokens","squashTokens","squashedTokens","lastToken","render","partials","config","getConfigTags","renderTokens","originalTemplate","buffer","symbol","renderSection","renderInverted","renderPartial","unescapedValue","escapedValue","rawValue","j","slice","subRender","indentPartial","partial","filteredIndentation","partialByNl","indentedValue","escape","getConfigEscape","String","version","defaultWriter","TypeError","typeStr","escapeHtml","s"],"mappings":"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","file":"mustache.f1fa0678.js","sourceRoot":"../application","sourcesContent":["// This file has been generated from mustache.mjs\n(function(global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n        typeof define === 'function' && define.amd ? define(factory) :\n        (global = global || self, global.Mustache = factory());\n}(this, (function() {\n    'use strict';\n\n    /*!\n     * mustache.js - Logic-less {{mustache}} templates with JavaScript\n     * http://github.com/janl/mustache.js\n     */\n\n    var objectToString = Object.prototype.toString;\n    var isArray = Array.isArray || function isArrayPolyfill(object) {\n        return objectToString.call(object) === '[object Array]';\n    };\n\n    function isFunction(object) {\n        return typeof object === 'function';\n    }\n\n    /**\n     * More correct typeof string handling array\n     * which normally returns typeof 'object'\n     */\n    function typeStr(obj) {\n        return isArray(obj) ? 'array' : typeof obj;\n    }\n\n    function escapeRegExp(string) {\n        return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n    }\n\n    /**\n     * Null safe way of checking whether or not an object,\n     * including its prototype, has a given property\n     */\n    function hasProperty(obj, propName) {\n        return obj != null && typeof obj === 'object' && (propName in obj);\n    }\n\n    /**\n     * Safe way of detecting whether or not the given thing is a primitive and\n     * whether it has the given property\n     */\n    function primitiveHasOwnProperty(primitive, propName) {\n        return (\n            primitive != null &&\n            typeof primitive !== 'object' &&\n            primitive.hasOwnProperty &&\n            primitive.hasOwnProperty(propName)\n        );\n    }\n\n    // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n    // See https://github.com/janl/mustache.js/issues/189\n    var regExpTest = RegExp.prototype.test;\n\n    function testRegExp(re, string) {\n        return regExpTest.call(re, string);\n    }\n\n    var nonSpaceRe = /\\S/;\n\n    function isWhitespace(string) {\n        return !testRegExp(nonSpaceRe, string);\n    }\n\n    var entityMap = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#39;',\n        '/': '&#x2F;',\n        '`': '&#x60;',\n        '=': '&#x3D;'\n    };\n\n    function escapeHtml(string) {\n        return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap(s) {\n            return entityMap[s];\n        });\n    }\n\n    var whiteRe = /\\s*/;\n    var spaceRe = /\\s+/;\n    var equalsRe = /\\s*=/;\n    var curlyRe = /\\s*\\}/;\n    var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n    /**\n     * Breaks up the given `template` string into a tree of tokens. If the `tags`\n     * argument is given here it must be an array with two string values: the\n     * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n     * course, the default is to use mustaches (i.e. mustache.tags).\n     *\n     * A token is an array with at least 4 elements. The first element is the\n     * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n     * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n     * all text that appears outside a symbol this element is \"text\".\n     *\n     * The second element of a token is its \"value\". For mustache tags this is\n     * whatever else was inside the tag besides the opening symbol. For text tokens\n     * this is the text itself.\n     *\n     * The third and fourth elements of the token are the start and end indices,\n     * respectively, of the token in the original template.\n     *\n     * Tokens that are the root node of a subtree contain two more elements: 1) an\n     * array of tokens in the subtree and 2) the index in the original template at\n     * which the closing tag for that section begins.\n     *\n     * Tokens for partials also contain two more elements: 1) a string value of\n     * indendation prior to that tag and 2) the index of that tag on that line -\n     * eg a value of 2 indicates the partial is the third tag on this line.\n     */\n    function parseTemplate(template, tags) {\n        if (!template)\n            return [];\n        var lineHasNonSpace = false;\n        var sections = []; // Stack to hold section tokens\n        var tokens = []; // Buffer to hold the tokens\n        var spaces = []; // Indices of whitespace tokens on the current line\n        var hasTag = false; // Is there a {{tag}} on the current line?\n        var nonSpace = false; // Is there a non-space char on the current line?\n        var indentation = ''; // Tracks indentation for tags that use it\n        var tagIndex = 0; // Stores a count of number of tags encountered on a line\n\n        // Strips all whitespace tokens array for the current line\n        // if there was a {{#tag}} on it and otherwise only space.\n        function stripSpace() {\n            if (hasTag && !nonSpace) {\n                while (spaces.length)\n                    delete tokens[spaces.pop()];\n            } else {\n                spaces = [];\n            }\n\n            hasTag = false;\n            nonSpace = false;\n        }\n\n        var openingTagRe, closingTagRe, closingCurlyRe;\n\n        function compileTags(tagsToCompile) {\n            if (typeof tagsToCompile === 'string')\n                tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n            if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n                throw new Error('Invalid tags: ' + tagsToCompile);\n\n            openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n            closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n            closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n        }\n\n        compileTags(tags || mustache.tags);\n\n        var scanner = new Scanner(template);\n\n        var start, type, value, chr, token, openSection;\n        while (!scanner.eos()) {\n            start = scanner.pos;\n\n            // Match any text between tags.\n            value = scanner.scanUntil(openingTagRe);\n\n            if (value) {\n                for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n                    chr = value.charAt(i);\n\n                    if (isWhitespace(chr)) {\n                        spaces.push(tokens.length);\n                        indentation += chr;\n                    } else {\n                        nonSpace = true;\n                        lineHasNonSpace = true;\n                        indentation += ' ';\n                    }\n\n                    tokens.push(['text', chr, start, start + 1]);\n                    start += 1;\n\n                    // Check for whitespace on the current line.\n                    if (chr === '\\n') {\n                        stripSpace();\n                        indentation = '';\n                        tagIndex = 0;\n                        lineHasNonSpace = false;\n                    }\n                }\n            }\n\n            // Match the opening tag.\n            if (!scanner.scan(openingTagRe))\n                break;\n\n            hasTag = true;\n\n            // Get the tag type.\n            type = scanner.scan(tagRe) || 'name';\n            scanner.scan(whiteRe);\n\n            // Get the tag value.\n            if (type === '=') {\n                value = scanner.scanUntil(equalsRe);\n                scanner.scan(equalsRe);\n                scanner.scanUntil(closingTagRe);\n            } else if (type === '{') {\n                value = scanner.scanUntil(closingCurlyRe);\n                scanner.scan(curlyRe);\n                scanner.scanUntil(closingTagRe);\n                type = '&';\n            } else {\n                value = scanner.scanUntil(closingTagRe);\n            }\n\n            // Match the closing tag.\n            if (!scanner.scan(closingTagRe))\n                throw new Error('Unclosed tag at ' + scanner.pos);\n\n            if (type == '>') {\n                token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];\n            } else {\n                token = [type, value, start, scanner.pos];\n            }\n            tagIndex++;\n            tokens.push(token);\n\n            if (type === '#' || type === '^') {\n                sections.push(token);\n            } else if (type === '/') {\n                // Check section nesting.\n                openSection = sections.pop();\n\n                if (!openSection)\n                    throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n                if (openSection[1] !== value)\n                    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n            } else if (type === 'name' || type === '{' || type === '&') {\n                nonSpace = true;\n            } else if (type === '=') {\n                // Set the tags for the next time around.\n                compileTags(value);\n            }\n        }\n\n        stripSpace();\n\n        // Make sure there are no open sections when we're done.\n        openSection = sections.pop();\n\n        if (openSection)\n            throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n        return nestTokens(squashTokens(tokens));\n    }\n\n    /**\n     * Combines the values of consecutive text tokens in the given `tokens` array\n     * to a single token.\n     */\n    function squashTokens(tokens) {\n        var squashedTokens = [];\n\n        var token, lastToken;\n        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n            token = tokens[i];\n\n            if (token) {\n                if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n                    lastToken[1] += token[1];\n                    lastToken[3] = token[3];\n                } else {\n                    squashedTokens.push(token);\n                    lastToken = token;\n                }\n            }\n        }\n\n        return squashedTokens;\n    }\n\n    /**\n     * Forms the given array of `tokens` into a nested tree structure where\n     * tokens that represent a section have two additional items: 1) an array of\n     * all tokens that appear in that section and 2) the index in the original\n     * template that represents the end of that section.\n     */\n    function nestTokens(tokens) {\n        var nestedTokens = [];\n        var collector = nestedTokens;\n        var sections = [];\n\n        var token, section;\n        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n            token = tokens[i];\n\n            switch (token[0]) {\n                case '#':\n                case '^':\n                    collector.push(token);\n                    sections.push(token);\n                    collector = token[4] = [];\n                    break;\n                case '/':\n                    section = sections.pop();\n                    section[5] = token[2];\n                    collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n                    break;\n                default:\n                    collector.push(token);\n            }\n        }\n\n        return nestedTokens;\n    }\n\n    /**\n     * A simple string scanner that is used by the template parser to find\n     * tokens in template strings.\n     */\n    function Scanner(string) {\n        this.string = string;\n        this.tail = string;\n        this.pos = 0;\n    }\n\n    /**\n     * Returns `true` if the tail is empty (end of string).\n     */\n    Scanner.prototype.eos = function eos() {\n        return this.tail === '';\n    };\n\n    /**\n     * Tries to match the given regular expression at the current position.\n     * Returns the matched text if it can match, the empty string otherwise.\n     */\n    Scanner.prototype.scan = function scan(re) {\n        var match = this.tail.match(re);\n\n        if (!match || match.index !== 0)\n            return '';\n\n        var string = match[0];\n\n        this.tail = this.tail.substring(string.length);\n        this.pos += string.length;\n\n        return string;\n    };\n\n    /**\n     * Skips all text until the given regular expression can be matched. Returns\n     * the skipped string, which is the entire tail if no match can be made.\n     */\n    Scanner.prototype.scanUntil = function scanUntil(re) {\n        var index = this.tail.search(re),\n            match;\n\n        switch (index) {\n            case -1:\n                match = this.tail;\n                this.tail = '';\n                break;\n            case 0:\n                match = '';\n                break;\n            default:\n                match = this.tail.substring(0, index);\n                this.tail = this.tail.substring(index);\n        }\n\n        this.pos += match.length;\n\n        return match;\n    };\n\n    /**\n     * Represents a rendering context by wrapping a view object and\n     * maintaining a reference to the parent context.\n     */\n    function Context(view, parentContext) {\n        this.view = view;\n        this.cache = {\n            '.': this.view\n        };\n        this.parent = parentContext;\n    }\n\n    /**\n     * Creates a new context using the given view with this context\n     * as the parent.\n     */\n    Context.prototype.push = function push(view) {\n        return new Context(view, this);\n    };\n\n    /**\n     * Returns the value of the given name in this context, traversing\n     * up the context hierarchy if the value is absent in this context's view.\n     */\n    Context.prototype.lookup = function lookup(name) {\n        var cache = this.cache;\n\n        var value;\n        if (cache.hasOwnProperty(name)) {\n            value = cache[name];\n        } else {\n            var context = this,\n                intermediateValue, names, index, lookupHit = false;\n\n            while (context) {\n                if (name.indexOf('.') > 0) {\n                    intermediateValue = context.view;\n                    names = name.split('.');\n                    index = 0;\n\n                    /**\n                     * Using the dot notion path in `name`, we descend through the\n                     * nested objects.\n                     *\n                     * To be certain that the lookup has been successful, we have to\n                     * check if the last object in the path actually has the property\n                     * we are looking for. We store the result in `lookupHit`.\n                     *\n                     * This is specially necessary for when the value has been set to\n                     * `undefined` and we want to avoid looking up parent contexts.\n                     *\n                     * In the case where dot notation is used, we consider the lookup\n                     * to be successful even if the last \"object\" in the path is\n                     * not actually an object but a primitive (e.g., a string, or an\n                     * integer), because it is sometimes useful to access a property\n                     * of an autoboxed primitive, such as the length of a string.\n                     **/\n                    while (intermediateValue != null && index < names.length) {\n                        if (index === names.length - 1)\n                            lookupHit = (\n                                hasProperty(intermediateValue, names[index]) ||\n                                primitiveHasOwnProperty(intermediateValue, names[index])\n                            );\n\n                        intermediateValue = intermediateValue[names[index++]];\n                    }\n                } else {\n                    intermediateValue = context.view[name];\n\n                    /**\n                     * Only checking against `hasProperty`, which always returns `false` if\n                     * `context.view` is not an object. Deliberately omitting the check\n                     * against `primitiveHasOwnProperty` if dot notation is not used.\n                     *\n                     * Consider this example:\n                     * ```\n                     * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\n                     * ```\n                     *\n                     * If we were to check also against `primitiveHasOwnProperty`, as we do\n                     * in the dot notation case, then render call would return:\n                     *\n                     * \"The length of a football field is 9.\"\n                     *\n                     * rather than the expected:\n                     *\n                     * \"The length of a football field is 100 yards.\"\n                     **/\n                    lookupHit = hasProperty(context.view, name);\n                }\n\n                if (lookupHit) {\n                    value = intermediateValue;\n                    break;\n                }\n\n                context = context.parent;\n            }\n\n            cache[name] = value;\n        }\n\n        if (isFunction(value))\n            value = value.call(this.view);\n\n        return value;\n    };\n\n    /**\n     * A Writer knows how to take a stream of tokens and render them to a\n     * string, given a context. It also maintains a cache of templates to\n     * avoid the need to parse the same template twice.\n     */\n    function Writer() {\n        this.templateCache = {\n            _cache: {},\n            set: function set(key, value) {\n                this._cache[key] = value;\n            },\n            get: function get(key) {\n                return this._cache[key];\n            },\n            clear: function clear() {\n                this._cache = {};\n            }\n        };\n    }\n\n    /**\n     * Clears all cached templates in this writer.\n     */\n    Writer.prototype.clearCache = function clearCache() {\n        if (typeof this.templateCache !== 'undefined') {\n            this.templateCache.clear();\n        }\n    };\n\n    /**\n     * Parses and caches the given `template` according to the given `tags` or\n     * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\n     * that is generated from the parse.\n     */\n    Writer.prototype.parse = function parse(template, tags) {\n        var cache = this.templateCache;\n        var cacheKey = template + ':' + (tags || mustache.tags).join(':');\n        var isCacheEnabled = typeof cache !== 'undefined';\n        var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\n\n        if (tokens == undefined) {\n            tokens = parseTemplate(template, tags);\n            isCacheEnabled && cache.set(cacheKey, tokens);\n        }\n        return tokens;\n    };\n\n    /**\n     * High-level method that is used to render the given `template` with\n     * the given `view`.\n     *\n     * The optional `partials` argument may be an object that contains the\n     * names and templates of partials that are used in the template. It may\n     * also be a function that is used to load partial templates on the fly\n     * that takes a single argument: the name of the partial.\n     *\n     * If the optional `config` argument is given here, then it should be an\n     * object with a `tags` attribute or an `escape` attribute or both.\n     * If an array is passed, then it will be interpreted the same way as\n     * a `tags` attribute on a `config` object.\n     *\n     * The `tags` attribute of a `config` object must be an array with two\n     * string values: the opening and closing tags used in the template (e.g.\n     * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n     *\n     * The `escape` attribute of a `config` object must be a function which\n     * accepts a string as input and outputs a safely escaped string.\n     * If an `escape` function is not provided, then an HTML-safe string\n     * escaping function is used as the default.\n     */\n    Writer.prototype.render = function render(template, view, partials, config) {\n        var tags = this.getConfigTags(config);\n        var tokens = this.parse(template, tags);\n        var context = (view instanceof Context) ? view : new Context(view, undefined);\n        return this.renderTokens(tokens, context, partials, template, config);\n    };\n\n    /**\n     * Low-level method that renders the given array of `tokens` using\n     * the given `context` and `partials`.\n     *\n     * Note: The `originalTemplate` is only ever used to extract the portion\n     * of the original template that was contained in a higher-order section.\n     * If the template doesn't use higher-order sections, this argument may\n     * be omitted.\n     */\n    Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {\n        var buffer = '';\n\n        var token, symbol, value;\n        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n            value = undefined;\n            token = tokens[i];\n            symbol = token[0];\n\n            if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);\n            else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);\n            else if (symbol === '>') value = this.renderPartial(token, context, partials, config);\n            else if (symbol === '&') value = this.unescapedValue(token, context);\n            else if (symbol === 'name') value = this.escapedValue(token, context, config);\n            else if (symbol === 'text') value = this.rawValue(token);\n\n            if (value !== undefined)\n                buffer += value;\n        }\n\n        return buffer;\n    };\n\n    Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {\n        var self = this;\n        var buffer = '';\n        var value = context.lookup(token[1]);\n\n        // This function is used to render an arbitrary template\n        // in the current context by higher-order sections.\n        function subRender(template) {\n            return self.render(template, context, partials, config);\n        }\n\n        if (!value) return;\n\n        if (isArray(value)) {\n            for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n                buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\n            }\n        } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n            buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\n        } else if (isFunction(value)) {\n            if (typeof originalTemplate !== 'string')\n                throw new Error('Cannot use higher-order sections without the original template');\n\n            // Extract the portion of the original template that the section contains.\n            value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n            if (value != null)\n                buffer += value;\n        } else {\n            buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\n        }\n        return buffer;\n    };\n\n    Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {\n        var value = context.lookup(token[1]);\n\n        // Use JavaScript's definition of falsy. Include empty arrays.\n        // See https://github.com/janl/mustache.js/issues/186\n        if (!value || (isArray(value) && value.length === 0))\n            return this.renderTokens(token[4], context, partials, originalTemplate, config);\n    };\n\n    Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {\n        var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\n        var partialByNl = partial.split('\\n');\n        for (var i = 0; i < partialByNl.length; i++) {\n            if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\n                partialByNl[i] = filteredIndentation + partialByNl[i];\n            }\n        }\n        return partialByNl.join('\\n');\n    };\n\n    Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {\n        if (!partials) return;\n        var tags = this.getConfigTags(config);\n\n        var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n        if (value != null) {\n            var lineHasNonSpace = token[6];\n            var tagIndex = token[5];\n            var indentation = token[4];\n            var indentedValue = value;\n            if (tagIndex == 0 && indentation) {\n                indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\n            }\n            var tokens = this.parse(indentedValue, tags);\n            return this.renderTokens(tokens, context, partials, indentedValue, config);\n        }\n    };\n\n    Writer.prototype.unescapedValue = function unescapedValue(token, context) {\n        var value = context.lookup(token[1]);\n        if (value != null)\n            return value;\n    };\n\n    Writer.prototype.escapedValue = function escapedValue(token, context, config) {\n        var escape = this.getConfigEscape(config) || mustache.escape;\n        var value = context.lookup(token[1]);\n        if (value != null)\n            return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);\n    };\n\n    Writer.prototype.rawValue = function rawValue(token) {\n        return token[1];\n    };\n\n    Writer.prototype.getConfigTags = function getConfigTags(config) {\n        if (isArray(config)) {\n            return config;\n        } else if (config && typeof config === 'object') {\n            return config.tags;\n        } else {\n            return undefined;\n        }\n    };\n\n    Writer.prototype.getConfigEscape = function getConfigEscape(config) {\n        if (config && typeof config === 'object' && !isArray(config)) {\n            return config.escape;\n        } else {\n            return undefined;\n        }\n    };\n\n    var mustache = {\n        name: 'mustache.js',\n        version: '4.1.0',\n        tags: ['{{', '}}'],\n        clearCache: undefined,\n        escape: undefined,\n        parse: undefined,\n        render: undefined,\n        Scanner: undefined,\n        Context: undefined,\n        Writer: undefined,\n        /**\n         * Allows a user to override the default caching strategy, by providing an\n         * object with set, get and clear methods. This can also be used to disable\n         * the cache by setting it to the literal `undefined`.\n         */\n        set templateCache(cache) {\n            defaultWriter.templateCache = cache;\n        },\n        /**\n         * Gets the default or overridden caching object from the default writer.\n         */\n        get templateCache() {\n            return defaultWriter.templateCache;\n        }\n    };\n\n    // All high-level mustache.* functions use this writer.\n    var defaultWriter = new Writer();\n\n    /**\n     * Clears all cached templates in the default writer.\n     */\n    mustache.clearCache = function clearCache() {\n        return defaultWriter.clearCache();\n    };\n\n    /**\n     * Parses and caches the given template in the default writer and returns the\n     * array of tokens it contains. Doing this ahead of time avoids the need to\n     * parse templates on the fly as they are rendered.\n     */\n    mustache.parse = function parse(template, tags) {\n        return defaultWriter.parse(template, tags);\n    };\n\n    /**\n     * Renders the `template` with the given `view`, `partials`, and `config`\n     * using the default writer.\n     */\n    mustache.render = function render(template, view, partials, config) {\n        if (typeof template !== 'string') {\n            throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                'but \"' + typeStr(template) + '\" was given as the first ' +\n                'argument for mustache#render(template, view, partials)');\n        }\n\n        return defaultWriter.render(template, view, partials, config);\n    };\n\n    // Export the escaping function so that the user may override it.\n    // See https://github.com/janl/mustache.js/issues/244\n    mustache.escape = escapeHtml;\n\n    // Export these mainly for testing, but also for advanced usage.\n    mustache.Scanner = Scanner;\n    mustache.Context = Context;\n    mustache.Writer = Writer;\n\n    return mustache;\n\n})));"]}